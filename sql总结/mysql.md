# 一条SQL语句执行慢的原因是
### 第一种情况:大多数情况是正常的,偶尔出现很慢的情况
    1.数据库再刷新脏页
        脏页:当内存数据页和磁盘数据页上的内容不一致时，我们称这个内存页为脏页；
        我们想数据库插入数据时，数据库会在内存中吧对应字段数据更新，但是这些更新的字段不会马上持久化磁盘中去，
        而是把这些更新的记录写入到redo log日记中,等空闲的时候,再把数据同步到磁盘中去.日记中的容量是有限的,
        如果数据更新很频繁,日记就会被写满,这是我们只能暂停其他操作,全身心的吧数据同步到磁盘中去,
        这样就导致我们的sql语句平时正常,偶尔很慢.
        所以有时候sql语句执行时有时很慢,就是数据库在同步数据到磁盘的时候
    
    2.拿不到锁
        我们要执行语句时,这条语句涉及到的表别人再用,并且加锁了,我们拿不到锁,只能慢慢等待别人释放锁
        或者,表没有加锁,但是某一行加了锁,也不行.
        如果判断是否在等待锁,可以用show processlist这个命令来查看但是的状态
       
### 第二种情况:一直都这么慢
    1.字段没有索引
        如果字段没有索引,那么查询语句只能走全表扫描,时间会很长
    2.字段有索引但是没有用索引
        如果我们在字段左边做了运算,查询的时候就不会用索引
        如果我们在字段右边做了运算,查询的时候就会用到索引
    3.函数操作导致没有用上索引
        如果我们在查询的时候,对字段进行了函数操作,会导致没有用上索引
    4.  数据库自己选错了索引
        主键索引是存放整行字段的数据,而非主键索引是存放主键字段的值
        有时候就散字段上有索引,系统也不一定会走这个字段上的索引而是扫描全表
        这是因为系统在执行语句的时候,会进行预测,是走索引扫描的行数少,还是直接扫描行数少
        如果是全盘扫描的话,扫描的次数就是这个表的总行数,如果走索引的话,是先通过索引找到主键,通过主键索引来找到我们的整行数据,需要走两次索引
        所以,系统有可能走全表扫描而不走索引
        系统的这个判断是来源于系统的预测,如果要走索引的话,系统会预测走索引大概需要扫描多少行,如果预测到索引要比扫描的行数多很多,就可能不走索引而进行全表扫描了
        系统是怎么预测判断的呢
        系统是根据缩印的区分度来判断的,一个索引上的不同值越多,相同数值的索引越少,意味着索引的区分度越高,也就是基数越大,所以符合缩印的行数越少,所以索引查询有更大的优势
        怎么知道索引的基数
        索引系统通过遍历部分数据,也就是通过采样的方式,预测索引的基数,既然是采样的话,就有可能出现失误的情况,有可能缩印的基数很大,但是采样的时候基数很小,系统就不走索引了,直接走全部扫描
        所以 由于抽样的失误,导致系统没有走索引,而是走了全表扫描,这就是查询语句执行很慢的原因之一
        既然预测错索引基数我们也可以强制走索引的方法查询,既然基数会预测错误,也就是说当我们有多个缩印的时候,系统也会选错索引

### 总结
    一条SQL语句执行很慢有两种情况
        1.大多数的情况下是正常的,偶尔很慢
            1).数据库刷新脏页时,日记写满了需要同步到磁盘中去
            2).执行的时候遇到锁
        2.一直执行很慢
            1).字段没有索引
            2).字段有索引没有运用
            3).在索引左侧进行运算,不会执行索引
            4).在字段进行了函数操作,不会执行索引
            5).系统
            