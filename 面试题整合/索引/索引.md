# **索引**
    索引SQL优化中占比很大,索引用的好,可以大大提升sql查询的效率,但是在有些情况下索引会
    降低sql查询的效率

#### 索引是万能的吗
        什么是索引: 索引就是一本书的目录,可以帮助我们快速进行查找,从而提高查询效率
        索引就是帮助数据库管理系统高效获取数据的数据结构
        我们不使用索引的时候,就必须从第一条数据开始进行扫描,直到吧整张表扫描完,才找
        到你需要的数据,这样很耗费时间,效率很慢.我们可以加入一些索引,但是有时候索引又
        万能的,有些情况使用索引也会让效率降低.
        索引的价值就是帮助我们在海量的数据中找到所需要的数据,如果量少的情况下,有没有
        索引影响不大.
        在数据表中,数据比较少的情况,是不需要建索引的.当重复的数据较多的时候,也不需要
        使用索引.
        百度网盘:https://pan.baidu.com/s/1qjOrQt_Mu9BisKWo54SMmw 提取码：nrdw
        实验证明:
            hreos 数据表一共69个英雄,数据量少.当我们对name进行条件查询的时候,索引前的
            效率
            图片地址:https://imgchr.com/i/U10IIS
            运行结果地址:https://imgchr.com/i/U10TPg

            hreos 数据表一共69个英雄,数据量少.当我们对name进行条件查询的时候,索引后的
            效率
            图片地址:https://imgchr.com/i/U10vZV
            运行结果地址:https://imgchr.com/i/U10xaT
        我们可以看得出来运行结果相同,但是创建了索引的字段的效率比没有创建索引的效率更低
        在数据量不大的时候,索引就发挥不了作用了;
        实验证明:
            ⼥⼉国的⼈⼝数据表 user_gender ⻅百度⽹盘中的 user_gender.sql。其中数据表中
            的 user_gender 字段取值为 0 或 1，0 代表⼥性，1 代表男性
            如果我们要筛选出这个国家中的男性，可以使⽤
            运行结果地址:https://imgchr.com/i/U3iAPA
            图片地址:https://imgchr.com/i/U3iZxP
            索引后的地址:https://imgchr.com/i/U3iQaQ
        其实索引的价值在于快速定位.如果你想要定位的数据源有很多,那么索引就是去了使用
        的价值.不过有些时候我们还要考虑着个字段的数值分布情况,有些特殊的字段也是可以  
        使用索引大大增加查找效率的.
#### 索引的种类
    索引的种类:
        从功能上来说,索引主要分4种:
            1.普通索引:普通索引是基础索引,没有任何约束,主要用来提高查询效率
            2.唯一索引:在普通索引的基础上增加了数据的唯一性的约束,一张表可以有多个唯一索引
            3.主键索引:在唯一索引上增加了不为空的约束,一张表中最多只能有一个主键索引
            4.全文索引:MySQL自带的全文啥全文索引只支持英文
        普通索引.唯一索引和主键索引都是一类索引,就是对数据的约束性不同.在一张数据表中
        只能有一个主键索引,因为数据存储在文件中只能按照一种顺序进行存储.但是可以有多个
        普通索引或者多个唯一索引.
        从物理实现方式来说,索引可以分为2种:
            1.聚集索引:聚集索引可以按照主键来排序存储数据,这样朝招的时候非常有效
            2,非聚集索引:数据库有单独的存储空间存放非狙击索引,这些索引项按照顺序
              储存的,但是索引项指向的内容是随机储存的.也就是说系统会进行两次查找
              第一次查找索引,第二次查找索引所对应的位置取出数据.非聚集索引不会把
              索引指向的内容直接放到索引后面,而是维护单独的索引表,不维护索引指向
              数据    
        聚集索引和非聚集索引的不同
            1.聚集索引后面储存的是我们想要的数据,非聚集索引的后面储存的是数据的
              位置 .非聚集索引不会影响数据表的物理存储顺序
            2.一个表只能有一个聚集索引,因为只有一种排序存储的方法,但可以有多个非
              聚集索引
            3.使用聚集索引的时候,数据的查询效率较高,但是对数据进行,插入,删除,更新
              操作,效率就会比非聚集索引底
        按照字段个数来说,有2种
            1.单一索引:索引列为1列时为单一索引,
            2.联合索引:多个列组合在一起创建的索引,联合索引创建时,我们要注意顺序问题
              顺序的不同,效率也不同.联合索引最左匹配原则,也就是基按照最左优先的方式
              进行索引的匹配
        总结:
            1.对 where子句的字段建立索引,可以大幅度提升查询效率
            2.采用聚集索引进行数据查询,比非聚集索引的查询效率高.如果查询次数比较多
            尽量使用主键索引进行数据查询
#### 总结
    使用索引可以让我们在海量的数据中快速查找到想要的数据,索引也存在一些不足的地方,
    比如占用存储空间.降低数据库操作的性能,如果有多个索引还会增加索引之间的选择时间.
    当我们使用索引的时候,需要平衡索引的利和弊
    在实际工作中,我们要根据徐缺个数据分布情况来决定是否使用索引.索引的本质是帮助我
    们提升数据检索的效率.
            
         
### **索引原理**
#### 索引结构的好坏
    数据库服务器有两种存储介质,分别为硬盘和内存,内存是临时储存,容量较小,安全性较差,
    发生意外时会造成数据丢失;硬盘属于永久存储,容量很大,并且比较安全,就就是为什么我
    们把数据存储到硬盘上.
    内存的读取速度很快,但是我们还是将索引存放到硬盘上,当我们在硬盘上进行查询时,产生
    了硬盘的I/O操作,硬盘的I/O操作存取小号的时间较高,我们通过索引查找数据是,要计算产
    生的磁盘I/O次数,次数哦越多,消耗的时间也就越大,所以我们要让索引的数据结构尽量减
    少磁盘I/O操作的次数,这要所消耗的时间也就会变小

#### 二叉树的局限性
    二分查找是一种高效的数据检索方式,时间复杂度为0(log2n)
    基础搜索树,搜索某个节点为key:
        1.如果key节点大于根节点,在右孩子中进行查找
        2.如果key节点小于根节点,在左孩子中进行查找
        3,如果key节点等于根节点,返回根节点
    举个例子对数列(34,22,89,5,23,77,91)创造出来的二分查找数如下图:
        图片地址:https://imgchr.com/i/U31cQO
                                    34
                               /        \
                             22         89
                           /   \      /   \
                         5     23   77    91
    特殊情况,二叉树的深度非常大,如下图:
        图片地址:https://imgchr.com/i/U31IYt
        `           5
                     \
                      22
                       \
                        23
                         \
                          34
                           \
                            77
                             \
                              89
                               \
                                91
        
    特殊情况的二分查找数在性能上已经退化成一条链表.为了解救这个问题,人们提出了平衡二分
    搜索树,他在二分搜索树上增加了约束,,每个节点的左右子树的高度差不能超过1,也就是说
    节点的左右子树仍然为平衡二叉树.
    平衡二叉树有很多种,包括平衡二叉搜索树,红黑树,树堆,伸展树.
    数据查询的时间主要依赖于磁盘的I/O的次数,如果我们采用二叉树的形式,通过平衡二叉搜索树
    进行改进,树的深度也是o(log2n),当n比较大时,深度也比较高:如图:
                                平衡二叉树
     L1                                 0
                                /            \
     L2                       0               0
                           /    \          /    \
     L3                  0       0       0       0
                      /    \   /  \    /  \    /  \
     L4             0      0 0    0  0    0  0    0
     
    每访问一次节点就需要进行一次磁盘I/O操作,对于上面的树来说,我们进行4次I/O操作,虽然平衡
    二叉树效率比较高,但是树的深度同样也高,这就一位这磁盘I/O次数多,会影响效率
    针对这样的数据,我们把二叉树改成M叉树如图:
                              平衡M叉树
                                          0
                               /         |         \
                             0           0         0
                         /  |  \     /  |  \    /  |  \
                       0   0   0   0   0   0  0   0   0
    这样次树的高度降低了,但数据量N大的时候,以及树的分叉树大的时候,M叉树的高度小于二叉树的
    高度
    
#### 什么是B树
    B树也叫B-树,他是一棵多路平衡查找数.我们描述一棵B树的时候需要指定它的阶数,阶数表示一个
    节点最多有多少个孩子节点,一般用字母M表示.当M=2时,就是二分搜索树
    一棵M阶B数定义如下:
        1.每个节点最多有m-1个关键字
        2.根节点最少有1个关键字
        3.非根节点至少有 Math.ceil(m/2)-1个关键字  
        4.每个节点中的关键在从左到右都是按照大小顺序排列.每个节点的左子树中的所有关键字都
        小于它,而右边都大于它
        5.所有叶子节点都位于同一层,根节点到每个叶子节点的长度都相等
         如图所示:https://imgchr.com/i/U3woQA
         
#### B树的插入操作
    插入操作是指插入一条记录即key,values键值对.如果数中存在也要插入的键值对,用需要插入
    的value替代旧的value,若不存在,在子叶中进行插入
        1）根据要插入的key的值，找到叶子结点并插入。
        2）判断当前结点key的个数是否小于等于m-1，若满足则结束，否则进行第3步。
        3）以结点中间的key为中心分裂成左右两部分，然后将这个中间的key插入到父结点中，这
        个key的左子树指向分裂后的左半部分，这个key的右子支指向分裂后的右半部分，然后将
        当前结点指向父结点，继续进行第3步。
    下面以5阶B树为例，介绍B树的插入操作，在5阶B树中，结点最多有4个key,最少有2个key
        1.在空中插入39
            img:https://imgchr.com/i/U3R6a9
            此时根节点就一个key
        2.继续插入22,97,41
            img:https://imgchr.com/i/U3R4KO
            根节点有4个key
        3.插入53
            img:https://imgchr.com/i/U3WpZQ
            插入后超过了最大允许的关键字个数4，所以以key值为41为中心进行分裂，结果如下图
            所示，分裂后当前结点指针指向父结点，满足B树条件，插入操作结束。当阶数m为偶数
            时，需要分裂时就不存在排序恰好在中间的key，那么我们选择中间位置的前一个key或
            中间位置的后一个key为中心进行分裂即可。
            img:https://imgchr.com/i/U3WudJ
        4.依次插入13，21，40，同样会造成分裂，结果如下图所示。
            img: https://imgchr.com/i/U3WrSP
        5.依次插入30，27, 33 ；36，35，34 ；24，29，结果如下图所示
            img:https://images2018.cnblogs.com/blog/834468/201804/834468-20180406232719931-1845157889.png
        6.插入key值为26的记录，插入后的结果如下图所示
            img:https://images2018.cnblogs.com/blog/834468/201804/834468-20180406232724001-1518264552.png
            当前结点需要以27为中心分裂，并向父结点进位27，然后当前结点指向父结点，结果如下图所示。
            img:https://images2018.cnblogs.com/blog/834468/201804/834468-20180406232732844-330586131.png
            进位后导致当前结点（即根结点）也需要分裂，分裂的结果如下图所示。
            img:https://images2018.cnblogs.com/blog/834468/201804/834468-20180406232737701-1115673096.png
        7.最后再依次插入key为17,28,29,31,32的记录，结果如下图所示
            img: https://images2018.cnblogs.com/blog/834468/201804/834468-20180406232748270-1888091858.png
        在实现B树的代码中，为了使代码编写更加容易，我们可以将结点中存储记录的数组长度定义为m而非m-1，这样
        方便底层的结点由于分裂向上层插入一个记录时，上层有多余的位置存储这个记录。同时，每个结点还可以存储
        它的父结点的引用，这样就不必编写递归程序。
        一般来说，对于确定的m和确定类型的记录，结点大小是固定的，无论它实际存储了多少个记录。但是分配固定结
        点大小的方法会存在浪费的情况，比如key为28,29所在的结点，还有2个key的位置没有使用，但是已经不可能继续
        在插入任何值了，因为这个结点的前序key是27,后继key是30,所有整数值都用完了。所以如果记录先按key的大小
        排好序，再插入到B树中，结点的使用率就会很低，最差情况下使用率仅为50%。
#### B树的删除
    删除操作是指，根据key删除记录，如果B树中的记录中不存对应key的记录，则删除失败。
        1.如果当前需要删除的key位于非叶子结点上，则用后继key（这里的后继key均指后继记录的意思）覆盖要删除的key
        ，然后在后继key所在的子支中删除该后继key。此时后继key一定位于叶子结点上，这个过程和二叉搜索树删除结点的
        方式类似。删除这个记录后执行第2步
        2.该结点key个数大于等于Math.ceil(m/2)-1，结束删除操作，否则执行第3步。
        3.如果兄弟结点key个数大于Math.ceil(m/2)-1，则父结点中的key下移到该结点，兄弟结点中的一个key上移，删除操
        作结束。
    否则，将父结点中的key下移与当前结点及它的兄弟结点中的key合并，形成一个新的结点。原父结点中的key的两个孩
    子指针就变成了一个孩子指针，指向这个新结点。然后当前结点的指针指向父结点，重复上第2步。
    有些结点它可能即有左兄弟，又有右兄弟，那么我们任意选择一个兄弟结点进行操作即可。
    下面以5阶B树为例，介绍B树的删除操作，5阶B树中，结点最多有4个key,最少有2个key   
          1,原始状态
            img: https://images2018.cnblogs.com/blog/834468/201804/834468-20180406232754144-973589199.png
          2.在上面的B树中删除21，删除后结点中的关键字个数仍然大于等2，所以删除结束
            img:https://images2018.cnblogs.com/blog/834468/201804/834468-20180406232800149-881832132.png                
          3.在上述情况下接着删除27。从上图可知27位于非叶子结点中，所以用27的后继替换它。从图中可以看出，27的
          后继为28，我们用28替换27，然后在28（原27）的右孩子结点中删除28。删除后的结果如下图所示  
            img:https://images2018.cnblogs.com/blog/834468/201804/834468-20180406232805316-736624542.png
            删除后发现，当前叶子结点的记录的个数小于2，而它的兄弟结点中有3个记录（当前结点还有一个右兄弟，
            选择右兄弟就会出现合并结点的情况，不论选哪一个都行，只是最后B树的形态会不一样而已），我们可以
            从兄弟结点中借取一个key。所以父结点中的28下移，兄弟结点中的26上移,删除结束。结果如下图所示。
            img:https://images2018.cnblogs.com/blog/834468/201804/834468-20180406232813762-797146286.png
          4.在上述情况下接着32，结果如下图
            img: https://images2018.cnblogs.com/blog/834468/201804/834468-20180406232817843-722364883.png
            当删除后，当前结点中只key，而兄弟结点中也仅有2个key。所以只能让父结点中的30下移和这个两个孩子
            结点中的key合并，成为一个新的结点，当前结点的指针指向父结点。结果如下图所示
            img:https://images2018.cnblogs.com/blog/834468/201804/834468-20180406232829066-149754287.png
          5.上述情况下，我们接着删除key为40的记录，删除后结果如下图所示
            img:https://images2018.cnblogs.com/blog/834468/201804/834468-20180406232837287-2101391374.png
            同理，当前结点的记录数小于2，兄弟结点中没有多余key，所以父结点中的key下移，和兄弟（这里我们选
            择左兄弟，选择右兄弟也可以）结点合并，合并后的指向当前结点的指针就指向了父结点
            img:https://images2018.cnblogs.com/blog/834468/201804/834468-20180406232846836-538278275.png
            同理，对于当前结点而言只能继续合并了，最后结果如下所示
            img:https://images2018.cnblogs.com/blog/834468/201804/834468-20180406232851299-447892778.png
#### 什么是B+树
    img:https://images2018.cnblogs.com/blog/834468/201804/834468-20180406232854940-1019144331.png
        1.若为空树，创建一个叶子结点，然后将记录插入其中，此时这个叶子结点也是根结点，插入操作结束。
        2.针对叶子类型结点：根据key值找到叶子结点，向这个叶子结点插入记录。插入后，若当前结点key的
        个数小于等于m-1，则插入结束。否则将这个叶子结点分裂成左右两个叶子结点，左叶子结点包含前m/2
        个记录，右结点包含剩下的记录，将第m/2+1个记录的key进位到父结点中（父结点一定是索引类型结点）
        ，进位到父结点的key左孩子指针向左结点,右孩子指针向右结点。将当前结点的指针指向父结点，然后执行第3步。
        3.针对索引类型结点：若当前结点key的个数小于等于m-1，则插入结束。否则，将这个索引类型结点分裂
        成两个索引结点，左索引结点包含前(m-1)/2个key，右结点包含m-(m-1)/2个key，将第m/2个key进位到父结点中，
        进位到父结点的key左孩子指向左结点, 进位到父结点的key右孩子指向右结点。将当前结点的指针指向父结点，
        然后重复第3步。
#### B+树插入
    下面是一颗5阶B树的插入过程，5阶B数的结点最少2个key，最多4个key。
        1.空树种插入5
            img:https://images2018.cnblogs.com/blog/834468/201804/834468-20180406232858129-694616618.png
        2.依次插入
            img:https://images2018.cnblogs.com/blog/834468/201804/834468-20180406232901391-1401289774.png
        3.插入16
            img:https://images2018.cnblogs.com/blog/834468/201804/834468-20180406232909712-1807724284.png
            插入16后超过了关键字的个数限制，所以要进行分裂。在叶子结点分裂时，分裂出来的左结点2个记录，
            右边3个记录，中间key成为索引结点中的key，分裂后当前结点指向了父结点（根结点）
        4.插入17
            img:https://images2018.cnblogs.com/blog/834468/201804/834468-20180406232913379-576202883.png
        5.插入18
            img:https://images2018.cnblogs.com/blog/834468/201804/834468-20180406232921679-618565224.png
            当前结点的关键字个数大于5，进行分裂。分裂成两个结点，左结点2个记录，右结点3个记录，关键字16进
            位到父结点（索引类型）中，将当前结点的指针指向父结点    
        6.插入若干个数
            img: https://images2018.cnblogs.com/blog/834468/201804/834468-20180406232945267-543224744.png               
#### B+树删除
    如果叶子结点中没有相应的key，则删除失败。否则执行下面的步骤
        1.删除叶子结点中对应的key。删除后若结点的key的个数大于等于Math.ceil(m-1)/2 – 1，删除操作结束,否则执行第2步。
        2.若兄弟结点key有富余（大于Math.ceil(m-1)/2 – 1），向兄弟结点借一个记录，同时用借到的key替换父结
        （指当前结点和兄弟结点共同的父结点）点中的key，删除结束。否则执行第3步。
        3.若兄弟结点中没有富余的key,则当前结点和兄弟结点合并成一个新的叶子结点，并删除父结点中的key
        （父结点中的这个key两边的孩子指针就变成了一个指针，正好指向这个新的叶子结点），将当前结点指向父结点
        （必为索引结点），执行第4步（第4步以后的操作和B树就完全一样了，主要是为了更新索引结点）。
        4.若索引结点的key的个数大于等于Math.ceil(m-1)/2 – 1，则删除操作结束。否则执行第5步
        5.若兄弟结点有富余，父结点key下移，兄弟结点key上移，删除结束。否则执行第6步
        6.当前结点和兄弟结点及父结点下移key合并成一个新的结点。将当前结点指向父结点，重复第4步。
    注意，通过B+树的删除操作后，索引结点中存在的key，不一定在叶子结点中存在对应的记录。
    下面是一颗5阶B树的删除过程，5阶B数的结点最少2个key，最多4个key。
        1.初始状态
            img:https://images2018.cnblogs.com/blog/834468/201804/834468-20180406232951603-2095664521.png
        2.删除22
            img:https://images2018.cnblogs.com/blog/834468/201804/834468-20180406232956857-909502342.png
        3.删除15:
            img:https://images2018.cnblogs.com/blog/834468/201804/834468-20180406233008129-433585803.png
            删除后当前结点只有一个key,不满足条件，而兄弟结点有三个key，可以从兄弟结点借一个关键字为9的记录,
            同时更新将父结点中的关键字由10也变为9
        4.删除7
            img:https://images2018.cnblogs.com/blog/834468/201804/834468-20180406233017339-92051658.png
            当前结点关键字个数小于2，（左）兄弟结点中的也没有富余的关键字（当前结点还有个右兄弟，不过选
            择任意一个进行分析就可以了，这里我们选择了左边的），所以当前结点和兄弟结点合并，并删除父结点
            中的key，当前结点指向父结点
            img:https://images2018.cnblogs.com/blog/834468/201804/834468-20180406233022828-172757536.png 
            此时当前结点的关键字个数小于2，兄弟结点的关键字也没有富余，所以父结点中的关键字下移，和两个孩子结点合并
            img:https://images2018.cnblogs.com/blog/834468/201804/834468-20180406233027773-1578264573.png
#### 总结
    磁盘的 I/O 操作次数对索引的使⽤效率⾄关重要。虽然传统的⼆叉树数据结构查找数 据的效率⾼，但很容易增加磁盘
     I/O 操作的次数，影响索引使⽤的效率。因此在构造 索引的时候，我们更倾向于采⽤“矮胖”的数据结构。 B 树和 
     B+树都可以作为索引的数据结构，在 MySQL 中采⽤的是 B+ 树，B+ 树在查 询性能上更稳定，在磁盘⻚⼤⼩相同的情
     况下，树的构造更加矮胖，所需要进⾏的磁 盘 I/O 次数更少，更适合进⾏关键字的范围查询。 能看出来第⼀个树的
     深度是 3，也就是说最多只需 3 次⽐较，就可以找到节点，⽽第 ⼆个树的深度是 7，最多需要 7 次⽐较才能找到节
     点。
                            
                    
                    